{"meta":{"title":"白日梦想家","subtitle":"未觉池塘春草梦, 阶前悟叶已秋声.","description":null,"author":"houtrry","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-08-25T08:37:50.000Z","updated":"2017-08-25T08:49:21.198Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-08-25T08:49:42.000Z","updated":"2017-08-25T08:50:02.912Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"IntentService源码分析","slug":"IntentService源码分析","date":"2017-08-25T07:41:08.000Z","updated":"2017-08-25T09:00:34.447Z","comments":true,"path":"2017/08/25/IntentService源码分析/","link":"","permalink":"http://yoursite.com/2017/08/25/IntentService源码分析/","excerpt":"","text":"###首先, 贴上IntentService的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public abstract class IntentService extends Service &#123; private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125; &#125; public IntentService(String name) &#123; super(); mName = name; &#125; public void setIntentRedelivery(boolean enabled) &#123; mRedelivery = enabled; &#125; @Override public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); &#125; @Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; @Override public void onDestroy() &#123; mServiceLooper.quit(); &#125; @Override @Nullable public IBinder onBind(Intent intent) &#123; return null; &#125; @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent);&#125; 其中, 有一个关键类HandlerThread1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125; public int getThreadId() &#123; return mTid; &#125;&#125; ###分析1.IntentService.onCreate12HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);thread.start(); 方法中创建了HandlerThread, 而HandlerThread继承自Thread, 即IntentService.onCreate方法中创建了一个子线程, 并开启了子线程.12mServiceLooper = thread.getLooper();mServiceHandler = new ServiceHandler(mServiceLooper); 将子线程的Looper交给内部类ServiceHandler, 而ServiceHandler继承自Handler.于是, 先来查看下HandlerThread到底做了什么. 2.HandlerThread继承自Thread, 那先看下run方法12345678910111213@Overridepublic void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 在run方法中, 我们看到了Looper.prepare()方法, 了解Handler的都知道, 在子线程中创建Handler, 需要先调用Looper.prepare()方法在子线程中创建looper.那这里run方法就清晰了, run方法创建了looper并且调用了Looper.loop()方法轮询Looper中的消息队列. 3.知道了ServiceHandler的looper来自于HandlerThread中创建的looper后, 我们可以知道, ServiceHandler.handleMessage将会执行在线程ServiceHandler中.12345@Overridepublic void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1);&#125; handleMessage中有onHandleIntent((Intent)msg.obj);和stopSelf(msg.arg1);onHandleIntent((Intent)msg.obj)方法就是我们要具体实现的方法, 我们实现这个方法, 将需要在子线程中完成的事情放到这里.stopSelf(msg.arg1)方法就是停止service. 4.那什么时候执行handleMessage方法中的内容呢?12345678910111213@Overridepublic void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125;@Overridepublic int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;&#125; 在IntentService#onStart方法中, mServiceHandler发出消息, 开始在子线程HandlerThread中执行onHandleIntent((Intent)msg.obj)和stopSelf(msg.arg1) ###总结1.在IntentService#onCreate方法中 ①创建子线程, 并在子线程中创建looper, 调用Looper.loop()方法轮询消息. ②用子线程中创建的Looper创建Handler. 2.在IntentService#onStart方法中, 通过mServiceHandler发送Message, 触发在子线程(HandlerThread所在线程)中执行IntentService#onHandleIntent方法和IntentService#stopSelf来执行任务, 并在任务结束的时候停止Service. 3.IntentService#onDestroy方法中, 执行mServiceLooper.quit();即, 停止loop的轮询.轮询停止后, 子线程HandlerThread也就结束了.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"源码分析","slug":"源码分析","permalink":"http://yoursite.com/tags/源码分析/"}]},{"title":"dagger2的使用小结","slug":"dagger2的使用小结","date":"2017-08-25T05:53:50.000Z","updated":"2017-08-25T09:00:16.968Z","comments":true,"path":"2017/08/25/dagger2的使用小结/","link":"","permalink":"http://yoursite.com/2017/08/25/dagger2的使用小结/","excerpt":"","text":"##Dagger2的使用 ###引入dagger2参考dagger2的GitHub说明.1234dependencies &#123; compile &apos;com.google.dagger:dagger:2.x&apos; annotationProcessor &apos;com.google.dagger:dagger-compiler:2.x&apos;&#125; ###几个常用的注解 ####@Module, @Component, @Inject, @Provides一. 生成对象的方式生成对象有两个方式:①.@Inject 注解提供方式：在所需类的构造函数中直接加上 @Inject 注解②.@Module 注解提供方式：通过新建一个专门的提供这类来提供类实例，然后在类名上面添加 @Module 注解，在类中自己定义方法，手动通过 new 来进行创建，这种主要是针对第三方库中，我们无法直接在构造函数中添加 @Inject 注解的情况。1.方式①1&gt; 用@Inject注解Bean类的构造方法1234567891011public class Apple &#123; @Inject public Apple() &#123; &#125; public String getDescription() &#123; return &quot;this is a red apple&quot;; &#125;&#125; 2&gt;使用@Component注解自己的Component类.比如下面的AppleComponent, 该类用@Component注解, 类中提供inject方法(方法名可以随便写, 一般用inject), 方法的参数Main9Activity是需要使用注解生成Apple的类.1234@Componentpublic interface AppleComponent &#123; void inject(Main9Activity main9Activity);&#125; 3&gt;编译项目, Android Studio Build–&gt;Make Project或者直接点击 4&gt;使用@Inject注解需要生成Apple的变量, 注入Main9Activity12345678910111213141516171819public class Main9Activity extends AppCompatActivity &#123; @BindView(R.id.textView9) TextView mTextView9; @Inject Apple mApple; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main9); ButterKnife.bind(this); DaggerAppleComponent.builder().build().inject(this); mTextView9.setText(mApple.getDescription()); &#125;&#125; 1DaggerAppleComponent.builder().build().inject(this); 这里, 上面第4步生成了DaggerAppleComponent, 实现了接口AppleComponent的inject方法, 此时, 注入Main9Activity, 将Main9Activity和Apple关联起来. 那么, 思考一个问题, 如果这个Apple类我们并不能修改, 也就是我们不能再Apple的构造函数上添加注解@Inject(比如第三方库里的类), 那我们怎么处理呢? 这就得用我们第二种注解方法了. 2.方式②1&gt; 生成一个普通的Bean12345678910111213141516public class Cloth &#123; private String color; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; @Override public String toString() &#123; return color + &quot;布料&quot;; &#125;&#125; 2&gt;构建Module注解@Module表明这是一个Module类, 方法上的@Provides表明该方法生成一个返回值为Cloth类型的依赖对象12345678910@Modulepublic class MainModule &#123; @Provides public Cloth getCloth() &#123; Cloth cloth = new Cloth(); cloth.setColor(&quot;红色&quot;); return cloth; &#125;&#125; 3&gt;书写Component1234@Component(modules=MainModule.class)public interface MainComponent &#123; void inject(MainActivity mainActivity);&#125; MainComponent是一个接口, 接口上用@Component注解, 表明这是一个Component, @Component的参数model=MainModule.class, 将MainMoudle和MainComponent关联起来, MainComponent中有一个inject的方法(方法名随意, 方法参数是需要使用到注解生成对象的类, 这里是需要在MainActivity中使用注解生成Cloth)4&gt;AS: Build–&gt;make Project5&gt;在MainActivity中使用注解.1234567891011121314151617public class Main3Activity extends AppCompatActivity &#123; private TextView mTextView; @Inject Cloth mCloth; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main3); mTextView = (TextView) findViewById(R.id.textView2); DaggerMainComponent.builder().mainModule(new MainModule()).build().inject(this); &#125;&#125; 二.Dagger2原理分析1.就使用上面方式一的例子吧.注入的目的是在Main9Activity中生成Apple的实例.我们从1DaggerAppleComponent.builder().build().inject(this); 开始分析吧.首先, 看下DaggerAppleComponent的源码123456789101112131415161718192021222324252627282930313233343536public final class DaggerAppleComponent implements AppleComponent &#123; private MembersInjector&lt;Main9Activity&gt; main9ActivityMembersInjector; private DaggerAppleComponent(Builder builder) &#123; assert builder != null; initialize(builder); &#125; public static Builder builder() &#123; return new Builder(); &#125; public static AppleComponent create() &#123; return new Builder().build(); &#125; @SuppressWarnings(&quot;unchecked&quot;) private void initialize(final Builder builder) &#123; this.main9ActivityMembersInjector = Main9Activity_MembersInjector.create(Apple_Factory.create()); &#125; @Override public void inject(Main9Activity main9Activity) &#123; main9ActivityMembersInjector.injectMembers(main9Activity); &#125; public static final class Builder &#123; private Builder() &#123;&#125; public AppleComponent build() &#123; return new DaggerAppleComponent(this); &#125; &#125;&#125; 2.DaggerAppleComponent.builder(): builder()方法里new 了一个DaggerAppleComponent.Builder, 并返回这个新建的Builder.3.DaggerAppleComponent.builder().build(): build()方法里new了DaggerAppleComponent的实例, 并将上个方法创建的Builder传给了DaggerAppleComponent的构造方法.在DaggerAppleComponent的构造方法里, 调用了DaggerAppleComponent.initialize(builder).在initialize里. 调用了Main9Activity_MembersInjector.create(Apple_Factory.create())方法.4.现在我们来看一下这个Main9Activity_MembersInjector.create(Apple_Factory.create())方法都做了什么事情.首先, 看下Apple_Factory的源码123456789101112public final class Apple_Factory implements Factory&lt;Apple&gt; &#123; private static final Apple_Factory INSTANCE = new Apple_Factory(); @Override public Apple get() &#123; return new Apple(); &#125; public static Factory&lt;Apple&gt; create() &#123; return INSTANCE; &#125;&#125; 从源码可知, Apple_Factory是个单例, create方法返回了该单例. get方法返回了一个Apple实例.这个时候就要注意了, 我们注解的目的是什么? 就是生成一个Apple实例啊, 那么, 现在我们知道, Apple_Factory的get方法创建了一个Apple实例. 记住这一点. 我们继续向下看Main9Activity_MembersInjector.123456789101112131415161718192021222324public final class Main9Activity_MembersInjector implements MembersInjector&lt;Main9Activity&gt; &#123; private final Provider&lt;Apple&gt; mAppleProvider; public Main9Activity_MembersInjector(Provider&lt;Apple&gt; mAppleProvider) &#123; assert mAppleProvider != null; this.mAppleProvider = mAppleProvider; &#125; public static MembersInjector&lt;Main9Activity&gt; create(Provider&lt;Apple&gt; mAppleProvider) &#123; return new Main9Activity_MembersInjector(mAppleProvider); &#125; @Override public void injectMembers(Main9Activity instance) &#123; if (instance == null) &#123; throw new NullPointerException(&quot;Cannot inject members into a null reference&quot;); &#125; instance.mApple = mAppleProvider.get(); &#125; public static void injectMApple(Main9Activity instance, Provider&lt;Apple&gt; mAppleProvider) &#123; instance.mApple = mAppleProvider.get(); &#125;&#125; Main9Activity_MembersInjector.create(Apple_Factory.create())方法到底做了什么呢?我们已知Apple_Factory.create()返回了单例Apple_Factory并且, Apple_Factory.get方法返回了Apple的实例.现在来看Main9Activity_MembersInjector.create, 在该方法中, new了一个Main9Activity_MembersInjector, 并将Apple_Factory的单例传给这个构造方法.在Main9Activity_MembersInjector的构造方法中, 将Apple_Factory的实例赋值给了Main9Activity_MembersInjector的成员变量mAppleProvider, 此时, 通过成员变量mAppleProvider的get方法就可以得到一个Apple的实例了.5.DaggerMainComponent.builder().mainModule(new MainModule()).build().inject(this): 最后这个inject方法做了什么呢?1234@Overridepublic void inject(Main9Activity main9Activity) &#123; main9ActivityMembersInjector.injectMembers(main9Activity);&#125; 1234567@Overridepublic void injectMembers(Main9Activity instance) &#123; if (instance == null) &#123; throw new NullPointerException(&quot;Cannot inject members into a null reference&quot;); &#125; instance.mApple = mAppleProvider.get();&#125; 此时, 我们终于找到了这个给Main9Activity的成员变量mApple赋值的地方了, 通过inject调用Main9Activity_MembersInjector.injectMembers方法, 在injectMembers方法中, 通过单例Apple_Factory.get获取Apple的实例, 并将该实例直接赋值飞Main9Activity.mApple, 到此, 给mApple生成实例的过程就结束了. 当然, 这里分析的只是最简单的使用模式, 随着Dagger2的使用, 代码会越来越复杂.在这里, 我们也可以明白, 为什么成员变量mApple不能是private或者protected的, 因为给mApple赋值的方式使用过instance.mApple来实现的, 如果mApple是private或者protected, 这里将会报错.","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Dagger2","slug":"Dagger2","permalink":"http://yoursite.com/tags/Dagger2/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-25T02:08:43.586Z","updated":"2017-08-25T02:08:43.586Z","comments":true,"path":"2017/08/25/hello-world/","link":"","permalink":"http://yoursite.com/2017/08/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}