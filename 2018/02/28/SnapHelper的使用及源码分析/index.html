<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>SnapHelper的使用及源码分析 | 白日梦想家 | 未觉池塘春草梦, 阶前梧叶已秋声.</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#00BCD4">
    
    
    <meta name="keywords" content="源码分析,SnapHelper,RecyclerView">
    <meta name="description" content="关于SnapHelper SnapHelper的功能： 在RecyclerView滑动结束时，定位到某个指定的位置。比如说，RecyclerView水平滑动，滑动结束后，item的中心与RecyclerView的水平中心对齐。 android.support.v7.widget.SnapHelper有子类android.support.v7.widget.LinearSnapHelper以及and">
<meta name="keywords" content="源码分析,SnapHelper,RecyclerView">
<meta property="og:type" content="article">
<meta property="og:title" content="SnapHelper的使用及源码分析">
<meta property="og:url" content="https://github.com/houtrry/2018/02/28/SnapHelper的使用及源码分析/index.html">
<meta property="og:site_name" content="白日梦想家">
<meta property="og:description" content="关于SnapHelper SnapHelper的功能： 在RecyclerView滑动结束时，定位到某个指定的位置。比如说，RecyclerView水平滑动，滑动结束后，item的中心与RecyclerView的水平中心对齐。 android.support.v7.widget.SnapHelper有子类android.support.v7.widget.LinearSnapHelper以及and">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-03-02T03:30:32.144Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SnapHelper的使用及源码分析">
<meta name="twitter:description" content="关于SnapHelper SnapHelper的功能： 在RecyclerView滑动结束时，定位到某个指定的位置。比如说，RecyclerView水平滑动，滑动结束后，item的中心与RecyclerView的水平中心对齐。 android.support.v7.widget.SnapHelper有子类android.support.v7.widget.LinearSnapHelper以及and">
    
        <link rel="alternate" type="application/atom+xml" title="白日梦想家" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/avatar.jpg">
    <link rel="stylesheet" href="/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">houtrry</h5>
          <a href="mailto:houtrry@hotmail.com" title="houtrry@hotmail.com" class="mail">houtrry@hotmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/houtrry" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">SnapHelper的使用及源码分析</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">SnapHelper的使用及源码分析</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-02-28T10:10:43.000Z" itemprop="datePublished" class="page-time">
  2018-02-28
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#关于SnapHelper"><span class="post-toc-number">1.</span> <span class="post-toc-text">关于SnapHelper</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#简单使用"><span class="post-toc-number">2.</span> <span class="post-toc-text">简单使用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#源码分析"><span class="post-toc-number">3.</span> <span class="post-toc-text">源码分析</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#从SnapHelper-attachToRecyclerView开始"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">从SnapHelper#attachToRecyclerView开始</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SnapHelper-destroyCallbacks"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">SnapHelper#destroyCallbacks</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SnapHelper-setupCallbacks"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">SnapHelper#setupCallbacks</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SnapHelper-mScrollListener"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">SnapHelper#mScrollListener</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SnapHelper-onFling"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">SnapHelper#onFling</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SnapHelper-snapFromFling"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">SnapHelper#snapFromFling</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SnapHelper-findTargetSnapPosition"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">SnapHelper#findTargetSnapPosition</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SnapHelper-snapToTargetExistingView"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">SnapHelper#snapToTargetExistingView</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SnapHelper-calculateDistanceToFinalSnap"><span class="post-toc-number">3.9.</span> <span class="post-toc-text">SnapHelper#calculateDistanceToFinalSnap</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SnapHelper-findSnapView"><span class="post-toc-number">3.10.</span> <span class="post-toc-text">SnapHelper#findSnapView</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#LinearSnapHelper-calculateDistanceToFinalSnap"><span class="post-toc-number">3.11.</span> <span class="post-toc-text">LinearSnapHelper#calculateDistanceToFinalSnap</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#LinearSnapHelper-distanceToCenter"><span class="post-toc-number">3.12.</span> <span class="post-toc-text">LinearSnapHelper#distanceToCenter</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#LinearSnapHelper-findSnapView"><span class="post-toc-number">3.13.</span> <span class="post-toc-text">LinearSnapHelper#findSnapView</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#LinearSnapHelper-findCenterView"><span class="post-toc-number">3.14.</span> <span class="post-toc-text">LinearSnapHelper#findCenterView</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#LinearSnapHelper-findTargetSnapPosition"><span class="post-toc-number">3.15.</span> <span class="post-toc-text">LinearSnapHelper#findTargetSnapPosition</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-number">4.</span> <span class="post-toc-text">总结</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-SnapHelper的使用及源码分析"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">SnapHelper的使用及源码分析</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-02-28 18:10:43" datetime="2018-02-28T10:10:43.000Z"  itemprop="datePublished">2018-02-28</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="关于SnapHelper"><a href="#关于SnapHelper" class="headerlink" title="关于SnapHelper"></a>关于SnapHelper</h2><ol>
<li>SnapHelper的功能： 在RecyclerView滑动结束时，定位到某个指定的位置。比如说，RecyclerView水平滑动，滑动结束后，item的中心与RecyclerView的水平中心对齐。</li>
<li>android.support.v7.widget.SnapHelper有子类android.support.v7.widget.LinearSnapHelper以及android.support.v7.widget.PagerSnapHelper。LinearSnapHelper使用场景：滑动结束后，item与RecyclerView的中心对齐，每次可以滑动多个item；PagerSnapHelper：通过RecyclerView实现类似ViewPager的效果，每次只能滑动一个item。</li>
</ol>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LinearSnapHelper linearSnapHelper = new LinearSnapHelper();</span><br><span class="line">linearSnapHelper.attachToRecyclerView(mRecyclerView);</span><br><span class="line"></span><br><span class="line">PagerSnapHelper pagerSnapHelper = new PagerSnapHelper();</span><br><span class="line">pagerSnapHelper.attachToRecyclerView(mRecyclerView);</span><br></pre></td></tr></table></figure>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="从SnapHelper-attachToRecyclerView开始"><a href="#从SnapHelper-attachToRecyclerView开始" class="headerlink" title="从SnapHelper#attachToRecyclerView开始"></a>从SnapHelper#attachToRecyclerView开始</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  public void attachToRecyclerView(@Nullable RecyclerView recyclerView)</span><br><span class="line">          throws IllegalStateException &#123;</span><br><span class="line">//判断是否已经关联过相同的recyclerView，关联过，则不再处理</span><br><span class="line">      if (mRecyclerView == recyclerView) &#123;</span><br><span class="line">          return; // nothing to do</span><br><span class="line">      &#125;</span><br><span class="line">      if (mRecyclerView != null) &#123;</span><br><span class="line">	//如果之前已经设置过别的recyclerView，那么，清空之前的设置</span><br><span class="line">          destroyCallbacks();</span><br><span class="line">      &#125;</span><br><span class="line">      mRecyclerView = recyclerView;</span><br><span class="line">      if (mRecyclerView != null) &#123;</span><br><span class="line">	//添加监听设置</span><br><span class="line">          setupCallbacks();</span><br><span class="line">          mGravityScroller = new Scroller(mRecyclerView.getContext(),</span><br><span class="line">                  new DecelerateInterpolator());</span><br><span class="line">	//初始化对齐， 比如中间对齐，那么，attachToRecyclerView后，RecyclerView中靠近中心的item并不一定就在RecyclerView的中心，那么，就需要调用该方法让该item对齐</span><br><span class="line">          snapToTargetExistingView();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>方法中有用到SnapHelper#destroyCallbacks，SnapHelper#setupCallbacks，以及SnapHelper#snapToTargetExistingView.</p>
<h3 id="SnapHelper-destroyCallbacks"><a href="#SnapHelper-destroyCallbacks" class="headerlink" title="SnapHelper#destroyCallbacks"></a>SnapHelper#destroyCallbacks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void destroyCallbacks() &#123;</span><br><span class="line">    mRecyclerView.removeOnScrollListener(mScrollListener);</span><br><span class="line">    mRecyclerView.setOnFlingListener(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>destroyCallbacks很简单，就是清空之前设置的OnScrollListener和OnFlingListener。</p>
<h3 id="SnapHelper-setupCallbacks"><a href="#SnapHelper-setupCallbacks" class="headerlink" title="SnapHelper#setupCallbacks"></a>SnapHelper#setupCallbacks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private void setupCallbacks() throws IllegalStateException &#123;</span><br><span class="line">    if (mRecyclerView.getOnFlingListener() != null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;An instance of OnFlingListener already set.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    mRecyclerView.addOnScrollListener(mScrollListener);</span><br><span class="line">    mRecyclerView.setOnFlingListener(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>setupCallbacks用来设置OnScrollListener和OnFlingListener。OnScrollListener的话用来监听RecyclerView的滑动状态变化。OnFlingListener的话，用来监听RecyclerView的Fling状态（指的是手指以一定的速度离开控件，控件会继续滑动，直到停止的状态）。  </p>
<p>我们先来看一下mScrollListener。</p>
<h3 id="SnapHelper-mScrollListener"><a href="#SnapHelper-mScrollListener" class="headerlink" title="SnapHelper#mScrollListener"></a>SnapHelper#mScrollListener</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final RecyclerView.OnScrollListener mScrollListener =</span><br><span class="line">        new RecyclerView.OnScrollListener() &#123;</span><br><span class="line">            boolean mScrolled = false;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123;</span><br><span class="line">                super.onScrollStateChanged(recyclerView, newState);</span><br><span class="line">                if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mScrolled) &#123;</span><br><span class="line">                    mScrolled = false;</span><br><span class="line">                    snapToTargetExistingView();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123;</span><br><span class="line">                if (dx != 0 || dy != 0) &#123;</span><br><span class="line">                    mScrolled = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>mScrolled初始为false，一旦RecyclerView有滑动，触发了onScrolled，也就是dx和dy有一个不等于0，那么mScrolled就会被置为true。再看看onScrollStateChanged，当RecyclerView的滑动状态有发生变化的时候，会触发该方法。如果滑动状态发生了变化，并且新的状态的停止（SCROLL_STATE_IDLE），RecyclerView曾经发生过滑动（mScrolled为true），那么就会触发snapToTargetExistingView方法。此时，我们整理一下逻辑，如果RecyclerView有x或者y方向的滑动，那么滑动停止的时候，会触发snapToTargetExistingView方法，来对齐RecyclerView。</p>
<h3 id="SnapHelper-onFling"><a href="#SnapHelper-onFling" class="headerlink" title="SnapHelper#onFling"></a>SnapHelper#onFling</h3><p>SnapHelper实现了android.support.v7.widget.RecyclerView.OnFlingListener。首先我们知道，RecyclerView是有Fling的，但我们以一定的速度松开手指时，RecyclerView会继续滑动，那么，SnapHelper#setupCallbacks中的mRecyclerView.setOnFlingListener(this)又有什么用呢？</p>
<p>在RecyclerView中，我们可以看到如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void setOnFlingListener(@Nullable OnFlingListener onFlingListener) &#123;</span><br><span class="line">    mOnFlingListener = onFlingListener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent e) &#123;</span><br><span class="line">    ...省略代码</span><br><span class="line"></span><br><span class="line">    switch (action) &#123;</span><br><span class="line">    ...省略代码</span><br><span class="line"></span><br><span class="line">        case MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            mVelocityTracker.addMovement(vtev);</span><br><span class="line">            eventAddedToVelocityTracker = true;</span><br><span class="line">            mVelocityTracker.computeCurrentVelocity(1000, mMaxFlingVelocity);</span><br><span class="line">            final float xvel = canScrollHorizontally</span><br><span class="line">                    ? -mVelocityTracker.getXVelocity(mScrollPointerId) : 0;</span><br><span class="line">            final float yvel = canScrollVertically</span><br><span class="line">                    ? -mVelocityTracker.getYVelocity(mScrollPointerId) : 0;</span><br><span class="line">            if (!((xvel != 0 || yvel != 0) &amp;&amp; fling((int) xvel, (int) yvel))) &#123;</span><br><span class="line">                setScrollState(SCROLL_STATE_IDLE);</span><br><span class="line">            &#125;</span><br><span class="line">            resetTouch();</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">    ...省略代码</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...省略代码</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean fling(int velocityX, int velocityY) &#123;</span><br><span class="line">    ...省略代码</span><br><span class="line"></span><br><span class="line">    if (!dispatchNestedPreFling(velocityX, velocityY)) &#123;</span><br><span class="line">        final boolean canScroll = canScrollHorizontal || canScrollVertical;</span><br><span class="line">        dispatchNestedFling(velocityX, velocityY, canScroll);</span><br><span class="line"></span><br><span class="line">        if (mOnFlingListener != null &amp;&amp; mOnFlingListener.onFling(velocityX, velocityY)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (canScroll) &#123;</span><br><span class="line">            velocityX = Math.max(-mMaxFlingVelocity, Math.min(velocityX, mMaxFlingVelocity));</span><br><span class="line">            velocityY = Math.max(-mMaxFlingVelocity, Math.min(velocityY, mMaxFlingVelocity));</span><br><span class="line">            mViewFlinger.fling(velocityX, velocityY);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RecyclerView中的mOnFlingListener默认为空，如果我们没有给mOnFlingListener赋值，那么RecyclerView将会按照默认的逻辑，继续滑动，直到停止，但是如果设置了mOnFlingListener，并且OnFlingListener.onFling返回true的话，就不会再执行RecyclerView的默认fling逻辑。</p>
<p>现在我们来看看SnapHelper#onFling</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public boolean onFling(int velocityX, int velocityY) &#123;</span><br><span class="line">      LayoutManager layoutManager = mRecyclerView.getLayoutManager();</span><br><span class="line">      if (layoutManager == null) &#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">      RecyclerView.Adapter adapter = mRecyclerView.getAdapter();</span><br><span class="line">      if (adapter == null) &#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">//获取RecyclerView最小能识别的速度</span><br><span class="line">      int minFlingVelocity = mRecyclerView.getMinFlingVelocity();</span><br><span class="line">//如果x或者y方向的速度有一个大于这个最小速度，则执行snapFromFling方法，否则，返回false，执行RecyclerView的默认fling逻辑。</span><br><span class="line">      return (Math.abs(velocityY) &gt; minFlingVelocity || Math.abs(velocityX) &gt; minFlingVelocity)</span><br><span class="line">              &amp;&amp; snapFromFling(layoutManager, velocityX, velocityY);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>OnFlingListener#onFling方法在手指离开RecyclerView的时刻触发，velocityX和velocityY分别是手指离开瞬间x方向和y方向的速度。</p>
<h3 id="SnapHelper-snapFromFling"><a href="#SnapHelper-snapFromFling" class="headerlink" title="SnapHelper#snapFromFling"></a>SnapHelper#snapFromFling</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  private boolean snapFromFling(@NonNull LayoutManager layoutManager, int velocityX,</span><br><span class="line">          int velocityY) &#123;</span><br><span class="line">      if (!(layoutManager instanceof ScrollVectorProvider)) &#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      RecyclerView.SmoothScroller smoothScroller = createSnapScroller(layoutManager);</span><br><span class="line">      if (smoothScroller == null) &#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">//根据当前的velocityX和velocityY，找到RecyclerView应该滑动到哪个位置</span><br><span class="line">      int targetPosition = findTargetSnapPosition(layoutManager, velocityX, velocityY);</span><br><span class="line">      if (targetPosition == RecyclerView.NO_POSITION) &#123;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      smoothScroller.setTargetPosition(targetPosition);</span><br><span class="line">//开始滑动</span><br><span class="line">      layoutManager.startSmoothScroll(smoothScroller);</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>根据手指松开的瞬间的velocityX和velocityY，判断RecyclerView最终应该停在哪个位置，然后，调用layoutManager.startSmoothScroll来滑动到这个位置，返回true，表示RecyclerView最终会执行这个Fling逻辑，而不是RecycerView默认的Fling逻辑。</p>
<h3 id="SnapHelper-findTargetSnapPosition"><a href="#SnapHelper-findTargetSnapPosition" class="headerlink" title="SnapHelper#findTargetSnapPosition"></a>SnapHelper#findTargetSnapPosition</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public abstract int findTargetSnapPosition(LayoutManager layoutManager, int velocityX,</span><br><span class="line">        int velocityY);</span><br></pre></td></tr></table></figure>
<p>该方法是SnapHelper中的抽象方法，需要子类实现。<br>首先我们需要明确一下几点：  </p>
<ol>
<li>该方法什么时候触发：手指离开RecyclerView的瞬间，即Fling刚开始的瞬间，执行该方法。</li>
<li>该方法有什么用：根据velocityX和velocityY判断RecyclerView的fling状态结束的时候，RecyclerView应该停在哪个位置</li>
</ol>
<h3 id="SnapHelper-snapToTargetExistingView"><a href="#SnapHelper-snapToTargetExistingView" class="headerlink" title="SnapHelper#snapToTargetExistingView"></a>SnapHelper#snapToTargetExistingView</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  void snapToTargetExistingView() &#123;</span><br><span class="line">      if (mRecyclerView == null) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      LayoutManager layoutManager = mRecyclerView.getLayoutManager();</span><br><span class="line">      if (layoutManager == null) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">//找到当前最靠近对齐位置（比如说中间）的item view</span><br><span class="line">      View snapView = findSnapView(layoutManager);</span><br><span class="line">      if (snapView == null) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">//计算最靠近对齐位置的item view距离最终需要对齐的位置的距离（还有多少距离才能最终对齐）</span><br><span class="line">      int[] snapDistance = calculateDistanceToFinalSnap(layoutManager, snapView);</span><br><span class="line">      if (snapDistance[0] != 0 || snapDistance[1] != 0) &#123;</span><br><span class="line">	//如果还没对齐，则调用方法对齐</span><br><span class="line">          mRecyclerView.smoothScrollBy(snapDistance[0], snapDistance[1]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>  
<p>我们需要回顾一下，SnapHelper#snapToTargetExistingView这个方法什么时候调用呢？</p>
<ol>
<li>SnapHelper#attachToRecyclerView的时候，也就是初始化的时候，将初始状态按要求对齐</li>
<li>RecyclerView出现过滑动后，滑动停止的时候调用（ScrollListener#onScrollStateChanged中）</li>
</ol>
<h3 id="SnapHelper-calculateDistanceToFinalSnap"><a href="#SnapHelper-calculateDistanceToFinalSnap" class="headerlink" title="SnapHelper#calculateDistanceToFinalSnap"></a>SnapHelper#calculateDistanceToFinalSnap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">public abstract int[] calculateDistanceToFinalSnap(@NonNull LayoutManager layoutManager,</span><br><span class="line">        @NonNull View targetView);</span><br></pre></td></tr></table></figure>  
<p>抽象方法，需要子类去实现。该方法用来计算离对齐位置最近的item view距离最终的对齐的距离。</p>
<h3 id="SnapHelper-findSnapView"><a href="#SnapHelper-findSnapView" class="headerlink" title="SnapHelper#findSnapView"></a>SnapHelper#findSnapView</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">public abstract View findSnapView(LayoutManager layoutManager);</span><br></pre></td></tr></table></figure>  
<p>抽象方法，需要子类实现。该方法用来获取当前距离对齐位置最近的item view。</p>
<p>下面，我们通过android.support.v7.widget.LinearSnapHelper来说明一下Snaphelper三个抽象方法的实现逻辑。<br>首先，我们需要知道，LinearSnapHelper的对齐位置是RecyclerView的中心。</p>
<h3 id="LinearSnapHelper-calculateDistanceToFinalSnap"><a href="#LinearSnapHelper-calculateDistanceToFinalSnap" class="headerlink" title="LinearSnapHelper#calculateDistanceToFinalSnap"></a>LinearSnapHelper#calculateDistanceToFinalSnap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int[] calculateDistanceToFinalSnap(</span><br><span class="line">          @NonNull RecyclerView.LayoutManager layoutManager, @NonNull View targetView) &#123;</span><br><span class="line">      int[] out = new int[2];</span><br><span class="line">//如果RecyclerVIew支持横向滑动，则计算需要移动的距离，不支持横向滑动，那么距离就是0</span><br><span class="line">      if (layoutManager.canScrollHorizontally()) &#123;</span><br><span class="line">          out[0] = distanceToCenter(layoutManager, targetView,</span><br><span class="line">                  getHorizontalHelper(layoutManager));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          out[0] = 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">//如果RecyclerVIew支持纵向滑动，则计算需要移动的距离，不支持纵向滑动，那么距离就是0</span><br><span class="line">      if (layoutManager.canScrollVertically()) &#123;</span><br><span class="line">          out[1] = distanceToCenter(layoutManager, targetView,</span><br><span class="line">                  getVerticalHelper(layoutManager));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          out[1] = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      return out;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>  
<p>该方法返回的结果是一个长度为2的int数组，数组的第一个元素是snapView（当前距离对齐位置最近的item view） 为对齐在x方向需要移动的距离，同理，数组的第二个元素是snapView（当前距离对齐位置最近的item view） 为对齐在y方向需要移动的距离。</p>
<h3 id="LinearSnapHelper-distanceToCenter"><a href="#LinearSnapHelper-distanceToCenter" class="headerlink" title="LinearSnapHelper#distanceToCenter"></a>LinearSnapHelper#distanceToCenter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private int distanceToCenter(@NonNull RecyclerView.LayoutManager layoutManager,</span><br><span class="line">        @NonNull View targetView, OrientationHelper helper) &#123;</span><br><span class="line">    final int childCenter = helper.getDecoratedStart(targetView)</span><br><span class="line">            + (helper.getDecoratedMeasurement(targetView) / 2);</span><br><span class="line">    final int containerCenter;</span><br><span class="line">    if (layoutManager.getClipToPadding()) &#123;</span><br><span class="line">        containerCenter = helper.getStartAfterPadding() + helper.getTotalSpace() / 2;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        containerCenter = helper.getEnd() / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return childCenter - containerCenter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p>通过辅助类来计算targetView（也就是上面的snapView，就是当前距离对齐位置最近的item view）距离中心位置的距离。</p>
<h3 id="LinearSnapHelper-findSnapView"><a href="#LinearSnapHelper-findSnapView" class="headerlink" title="LinearSnapHelper#findSnapView"></a>LinearSnapHelper#findSnapView</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public View findSnapView(RecyclerView.LayoutManager layoutManager) &#123;</span><br><span class="line">    if (layoutManager.canScrollVertically()) &#123;</span><br><span class="line">        return findCenterView(layoutManager, getVerticalHelper(layoutManager));</span><br><span class="line">    &#125; else if (layoutManager.canScrollHorizontally()) &#123;</span><br><span class="line">        return findCenterView(layoutManager, getHorizontalHelper(layoutManager));</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  
<p>可以看到，findSnapView实际上是调用的LinearSnapHelper#findCenterView</p>
<h3 id="LinearSnapHelper-findCenterView"><a href="#LinearSnapHelper-findCenterView" class="headerlink" title="LinearSnapHelper#findCenterView"></a>LinearSnapHelper#findCenterView</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  @Nullable</span><br><span class="line">  private View findCenterView(RecyclerView.LayoutManager layoutManager,</span><br><span class="line">          OrientationHelper helper) &#123;</span><br><span class="line">      int childCount = layoutManager.getChildCount();</span><br><span class="line">      if (childCount == 0) &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      View closestChild = null;</span><br><span class="line">      final int center;</span><br><span class="line">//获取RecyclerView中心的位置</span><br><span class="line">      if (layoutManager.getClipToPadding()) &#123;</span><br><span class="line">          center = helper.getStartAfterPadding() + helper.getTotalSpace() / 2;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          center = helper.getEnd() / 2;</span><br><span class="line">      &#125;</span><br><span class="line">      int absClosest = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">//遍历RecyclerView所有的子View，找出距离RecyclerView中心最近的item view</span><br><span class="line">      for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">          final View child = layoutManager.getChildAt(i);</span><br><span class="line">	//获取当前item view的中心点位置</span><br><span class="line">          int childCenter = helper.getDecoratedStart(child)</span><br><span class="line">                  + (helper.getDecoratedMeasurement(child) / 2);</span><br><span class="line"></span><br><span class="line">	//计算item view的中心与RecyclerView的中心的距离</span><br><span class="line">          int absDistance = Math.abs(childCenter - center);</span><br><span class="line"></span><br><span class="line">          /** if child center is closer than previous closest, set it as closest  **/</span><br><span class="line">	//这就很简单了，如果当前的item view距RecyclerView的中心近，就记录该item view，那么，循环结束的时候，closestChild就是要找的那个item view了</span><br><span class="line">          if (absDistance &lt; absClosest) &#123;</span><br><span class="line">              absClosest = absDistance;</span><br><span class="line">              closestChild = child;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return closestChild;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>  
<p>遍历RecyclerView所有的item view，计算每个item view的中心距RecyclerView中心的绝对距离，这个距离最小的一个，也就是我们要找的，距离对齐位置（LinearSnaphelper的对齐位置是RecyclerView的中心）最近的item view，也就是前面的snapView。</p>
<h3 id="LinearSnapHelper-findTargetSnapPosition"><a href="#LinearSnapHelper-findTargetSnapPosition" class="headerlink" title="LinearSnapHelper#findTargetSnapPosition"></a>LinearSnapHelper#findTargetSnapPosition</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int findTargetSnapPosition(RecyclerView.LayoutManager layoutManager, int velocityX,</span><br><span class="line">          int velocityY) &#123;</span><br><span class="line">      if (!(layoutManager instanceof RecyclerView.SmoothScroller.ScrollVectorProvider)) &#123;</span><br><span class="line">          return RecyclerView.NO_POSITION;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      final int itemCount = layoutManager.getItemCount();</span><br><span class="line">      if (itemCount == 0) &#123;</span><br><span class="line">          return RecyclerView.NO_POSITION;</span><br><span class="line">      &#125;</span><br><span class="line">//找到当前（也就是fling刚开始的瞬间）距离对齐位置最近的item view，也就是距离RecyclerVIew中心最近的item view</span><br><span class="line">      final View currentView = findSnapView(layoutManager);</span><br><span class="line">      if (currentView == null) &#123;</span><br><span class="line">          return RecyclerView.NO_POSITION;</span><br><span class="line">      &#125;</span><br><span class="line">//获取该currentView的在RecyclerVIew的位置</span><br><span class="line">      final int currentPosition = layoutManager.getPosition(currentView);</span><br><span class="line">      if (currentPosition == RecyclerView.NO_POSITION) &#123;</span><br><span class="line">          return RecyclerView.NO_POSITION;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      RecyclerView.SmoothScroller.ScrollVectorProvider vectorProvider =</span><br><span class="line">              (RecyclerView.SmoothScroller.ScrollVectorProvider) layoutManager;</span><br><span class="line">      // deltaJumps sign comes from the velocity which may not match the order of children in</span><br><span class="line">      // the LayoutManager. To overcome this, we ask for a vector from the LayoutManager to</span><br><span class="line">      // get the direction.</span><br><span class="line">      PointF vectorForEnd = vectorProvider.computeScrollVectorForPosition(itemCount - 1);</span><br><span class="line">      if (vectorForEnd == null) &#123;</span><br><span class="line">          // cannot get a vector for the given position.</span><br><span class="line">          return RecyclerView.NO_POSITION;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">//计算以当前的速度，Fling状态从开始到结束能滑动几个位置，也就算position能增加多少</span><br><span class="line">      int vDeltaJump, hDeltaJump;</span><br><span class="line">      if (layoutManager.canScrollHorizontally()) &#123;</span><br><span class="line">          hDeltaJump = estimateNextPositionDiffForFling(layoutManager,</span><br><span class="line">                  getHorizontalHelper(layoutManager), velocityX, 0);</span><br><span class="line">          if (vectorForEnd.x &lt; 0) &#123;</span><br><span class="line">              hDeltaJump = -hDeltaJump;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          hDeltaJump = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if (layoutManager.canScrollVertically()) &#123;</span><br><span class="line">          vDeltaJump = estimateNextPositionDiffForFling(layoutManager,</span><br><span class="line">                  getVerticalHelper(layoutManager), 0, velocityY);</span><br><span class="line">          if (vectorForEnd.y &lt; 0) &#123;</span><br><span class="line">              vDeltaJump = -vDeltaJump;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          vDeltaJump = 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      int deltaJump = layoutManager.canScrollVertically() ? vDeltaJump : hDeltaJump;</span><br><span class="line">      if (deltaJump == 0) &#123;</span><br><span class="line">          return RecyclerView.NO_POSITION;</span><br><span class="line">      &#125;</span><br><span class="line">//currentPosition是fling开始的时候距离RecyclerView对齐位置最近的item view的位置，deltaJump是此次fling从开始到结束，currentView滑动了几个item view宽度的距离，那么，targetPos必然就是fling结束的，距离RecyclerVIew对齐位置最近的item view的位置了</span><br><span class="line">      int targetPos = currentPosition + deltaJump;</span><br><span class="line">      if (targetPos &lt; 0) &#123;</span><br><span class="line">          targetPos = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if (targetPos &gt;= itemCount) &#123;</span><br><span class="line">          targetPos = itemCount - 1;</span><br><span class="line">      &#125;</span><br><span class="line">      return targetPos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  
<p>首先，找到fling开始的时候，距离对齐位置最近的item view（代码里是currentView，它的位置是currentPosition），然后，根据速度计算此次fling过程中，滑过几个item（代码中是deltaJump），最后计算出fling结束的时候，距离它的对齐位置最近的item view的position。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>初始化的时候（也就是SnapHelper#attachToRecyclerView），设置RecyclerView#addOnScrollListener 和RecyclerView.setOnFlingListener</li>
<li>在RecyclerView#addOnScrollListener中，如果RecyclerView有过滑动，则重新对齐</li>
<li>在RecyclerView.setOnFlingListener中处理RecyclerView的fling逻辑（替代RecyclerView原有的fling逻辑）</li>
<li>对齐的方法是SnapHelper#snapToTargetExistingView, 该方法就是找到当前（初始化的时候，或者是滑动结束的时候）距离对齐位置最近的item view，然后计算该item view距离对齐位置的距离，最后调用RecyclerView#smoothScrollBy方法实现对齐</li>
</ol>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-03-02T03:30:32.144Z" itemprop="dateUpdated">2018-03-02 11:30:32</time>
</span><br>


        
    </div>
    <footer>
        <a href="https://github.com/houtrry">
            <img src="/img/avatar.jpg" alt="houtrry">
            houtrry
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RecyclerView/">RecyclerView</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SnapHelper/">SnapHelper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/houtrry/2018/02/28/SnapHelper的使用及源码分析/&title=《SnapHelper的使用及源码分析》 — 白日梦想家&pic=https://github.com/houtrry/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/houtrry/2018/02/28/SnapHelper的使用及源码分析/&title=《SnapHelper的使用及源码分析》 — 白日梦想家&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/houtrry/2018/02/28/SnapHelper的使用及源码分析/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《SnapHelper的使用及源码分析》 — 白日梦想家&url=https://github.com/houtrry/2018/02/28/SnapHelper的使用及源码分析/&via=https://github.com/houtrry" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/houtrry/2018/02/28/SnapHelper的使用及源码分析/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/12/26/关于Java动态代理Proxy的一点思考/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">关于Java动态代理Proxy的一点思考</h4>
      </a>
    </div>
  
</nav>



    














</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>houtrry &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/houtrry/2018/02/28/SnapHelper的使用及源码分析/&title=《SnapHelper的使用及源码分析》 — 白日梦想家&pic=https://github.com/houtrry/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/houtrry/2018/02/28/SnapHelper的使用及源码分析/&title=《SnapHelper的使用及源码分析》 — 白日梦想家&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/houtrry/2018/02/28/SnapHelper的使用及源码分析/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《SnapHelper的使用及源码分析》 — 白日梦想家&url=https://github.com/houtrry/2018/02/28/SnapHelper的使用及源码分析/&via=https://github.com/houtrry" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/houtrry/2018/02/28/SnapHelper的使用及源码分析/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACrklEQVR42u3aQW7DMAwEwP7/0+21QGFnl5JcHyanwGltjgJIDMmvr/j1ffG6+vTv9d9Xru6cX9n8wsPDw9sU+j3gPtD7gO6fkixNEjMeHh7ead5VEMn7/GBoj5wkng8WPDw8vBfw2iW4hyULkaTmeHh4eO/ntYn4fbizlBoPDw/vf3lJoHnQbWE3T7sP1lrw8PDwYl7eRXrP+yP9PTw8PLzlrvpsUKBtViVHwjBaPDw8vAO8tuQ6K7zmRY31dBkPDw/vGV6+Ebelh70lj6T4++ELw8PDw1vmzRpUe8u17bFRDBPg4eHhHeblISanTZIit8j6znh4eHin7hw1vdqf/cn1nN0uBx4eHt45Xt7WSh4w2/pnbbPob/Dw8PCO8VYaYFHbaWuCXhxjeHh4eMd4eeF1NibVTpO2hYbLT/Hw8PAO8NYLEHnynReI27GDg6VbPDw8vBiWHw/tlr0y1LVU2MXDw8PbxGuT4w0nT9k8y5/44RvDw8PD28SblSRmDapZxjtbejw8PLzTvLwdtTJiNVuapD02rFjj4eHhHeDlralZHtu2xPIiBR4eHt453mzsqf2vZGlmyXc9dIWHh4e3zNuV/uYttLwcnJeG62IEHh4e3lZefgDM0vF2VGs2vHV5BuLh4eFt4rXjVm35oNi+y+WLYsDDw8N7kJds0207f7Z8KyNceHh4eOd4bYkhX45ZOt4ONODh4eE9z0u22vUSwywdX0m48fDw8PbydrWm2kBnC5QPY0W9Ozw8PLwRr918Z2l3ni7P0ushCQ8PD2+Bt+swaLfvFXBxMODh4eEd4+Wl2Lws25JmyfGH2PDw8PBexstT7b3XHzoY8PDw8Lby2mNj/WAYNszw8PDwjvGSxLcNa+XOK+VgPDw8vNO89gd/e6NZwXdXqQIPDw9vK+8HVJsiFgzpIHAAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="/js/main.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '迷路了吗?';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
